<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>0000-9999號碼產生工具GENv10</title>

  <style>
    :root{
      --bg: #f5f7fb;
      --card:#ffffff;
      --muted:#6b7280;
      --text:#111827;
      --line:#e5e7eb;
      --primary:#2563eb;
      --primary-2:#1d4ed8;
      --success:#16a34a;
      --warn:#f59e0b;
      --error:#ef4444;
      --note-bg:#f2f5ff;
      --note-line:#3b6ff9;
      --radius: 12px;
      --shadow: 0 6px 20px rgba(17,24,39,0.08);
    }

    *{ box-sizing: border-box; }
    body{
      margin:0;
      background:var(--bg);
      font-family: system-ui, -apple-system, "Segoe UI",
                   "Microsoft JhengHei", Arial, sans-serif;
      color:var(--text);
    }

    /* ✅ v10.7：整體窄版 */
    .page{
      max-width: 600px;
      margin: 22px auto 48px;
      padding: 0 14px;
    }

    /* Header */
    .header{
      background: linear-gradient(135deg, #ffffff 0%, #f7f9ff 100%);
      border:1px solid var(--line);
      border-radius: 16px;
      padding: 18px 18px 14px;
      box-shadow: var(--shadow);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      margin-bottom:16px;
    }
    .title-wrap{
      display:flex; flex-direction:column; gap:4px;
    }
    h1{
      margin:0;
      font-size: 22px;
      font-weight: 800;
      letter-spacing: 0.2px;
    }
    .subtitle{
      font-size: 13px;
      color: var(--muted);
    }
    .chip{
      font-size:12px;
      padding:6px 10px;
      background:#eef2ff;
      color:#3730a3;
      border-radius:999px;
      border:1px solid #e0e7ff;
      white-space:nowrap;
    }

    /* Cards / Steps */
    .card{
      background:var(--card);
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 16px 16px 14px;
      margin-bottom:14px;
      position: relative;
    }
    .card-head{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      margin-bottom:10px;
    }
    .step{
      display:flex; align-items:center; gap:10px;
    }
    .step-badge{
      width:30px; height:30px;
      border-radius:8px;
      background:#eef2ff;
      color:#3730a3;
      font-weight:700;
      display:flex; align-items:center; justify-content:center;
      border:1px solid #e0e7ff;
      flex: 0 0 auto;
    }
    .card-title{
      font-size:17px;
      font-weight:700;
    }

    /* Toggle note button */
    .toggle-btn{
      cursor:pointer;
      font-size:12px;
      color:var(--primary);
      user-select:none;
      display:flex; align-items:center; gap:6px;
      padding:6px 8px;
      border-radius:8px;
      border:1px dashed #dbe3ff;
      background:#f8faff;
      white-space:nowrap;
    }
    .toggle-btn:hover{ background:#eef2ff; }

    .note-box{
      background: var(--note-bg);
      border-left: 4px solid var(--note-line);
      padding: 12px 14px;
      border-radius: 8px;
      line-height: 1.6;
      color:#0f172a;
      font-size:13px;
      margin-top: 10px;
      white-space: pre-line;
    }
    .hidden{ display:none; }

    /* Form */
    .form-row{
      display:grid;
      grid-template-columns: 1fr 1fr; /* ✅ Grid 等分兩欄 */
      gap: 10px 12px;
      margin-top: 2px;
    }
    .form-item{
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    label{
      font-size:14px;
      font-weight:600;
      color:#111827;
    }
    .hint{
      font-size:12px;
      color:var(--muted);
      margin-top:2px;
    }
    input[type="number"], input[type="text"]{
      width:100%;
      height:36px;
      padding: 6px 10px;
      border-radius: 8px;
      border:1px solid var(--line);
      outline:none;
      font-size:14px;
      background:#fff;
      transition: border .15s ease, box-shadow .15s ease;
    }
    input[type="number"]:focus, input[type="text"]:focus{
      border-color:#93c5fd;
      box-shadow: 0 0 0 3px rgba(37,99,235,0.12);
    }
    input[type="file"]{
      width:100%;
      padding:8px;
      border:1px dashed var(--line);
      border-radius: 8px;
      background:#fafafa;
      font-size:14px;
    }

    .half-input {
      width: 100%;
      max-width: 100%;
    }

    .full-input{
      width:100%;
      max-width:100%;
    }

    /* Buttons */
    .actions{
      display:flex;
      align-items:center;
      justify-content:flex-end;
      gap:10px;
      flex-wrap:wrap;
      margin-top:6px;
    }
    button{
      border:0;
      cursor:pointer;
      font-size:15px;
      font-weight:700;
      padding: 10px 16px;
      border-radius: 10px;
      display:inline-flex; align-items:center; gap:8px;
      transition: transform .05s ease, background .15s ease, opacity .15s;
    }
    button:active{ transform: translateY(1px); }
    .btn-primary{
      background:var(--primary);
      color:#fff;
      box-shadow: 0 6px 14px rgba(37,99,235,0.25);
    }
    .btn-primary:hover{ background:var(--primary-2); }
    .btn-secondary{
      background:#0ea5a5;
      color:#fff;
      box-shadow: 0 6px 14px rgba(14,165,165,0.24);
    }
    .btn-secondary:hover{ opacity:0.95; }

    /* Status / message bar */
    .msg{
      margin-top:12px;
      padding: 12px 14px;
      border-radius: 10px;
      font-size:14px;
      white-space:pre-line;
      border:1px solid transparent;
      line-height:1.6;
    }
    .status-ok{
      background:#ecfdf3;
      border-color:#bbf7d0;
      color:#0f5132;
    }
    .status-warn{
      background:#fff7ed;
      border-color:#fed7aa;
      color:#7a4a00;
    }
    .status-error{
      background:#fef2f2;
      border-color:#fecaca;
      color:#7f1d1d;
    }

    /* Red summary block */
    #redSummary{
      margin-top:10px;
      font-size:13px;
      color:#0f172a;
      background:#f9fafb;
      border:1px solid var(--line);
      border-radius:8px;
      padding:10px 12px;
      white-space:pre-line;
    }

    /* Responsive */
    @media (max-width: 680px){
      .form-row{ grid-template-columns: 1fr; }
      .actions{ justify-content:stretch; }
      .actions button{ width:100%; justify-content:center; }
      .header{ flex-direction:column; align-items:flex-start; }
      h1{ font-size:20px; }
    }
  </style>
</head>

<body>
  <div class="page">
    <div class="header">
      <div class="title-wrap">
        <h1>0000-9999 號碼產生工具</h1>
        <div class="subtitle">Roll 家族選號 + 分散比例 + 行數倍數控制</div>
      </div>
      <div class="chip">RNG Tools</div>
    </div>

    <!-- Step 1 -->
    <section class="card">
      <div class="card-head">
        <div class="step">
          <div class="step-badge">1</div>
          <div class="card-title">上傳四位數紅字（txt 檔）</div>
        </div>
        <div class="toggle-btn" onclick="toggleNote('note1', this)">ⓘ 顯示說明</div>
      </div>

      <input type="file" id="redFile" accept=".txt" />

      <div class="form-row" style="margin-top:10px;">
        <div class="form-item">
          <label>紅字大萬 (Big)</label>
          <input type="number" id="redBigAmount" value="2" step="1" class="half-input" />
          <div class="hint">只套用在紅字檔案</div>
        </div>
        <div class="form-item">
          <label>紅字小萬 (Small)</label>
          <input type="number" id="redSmallAmount" value="4" step="1" class="half-input" />
          <div class="hint">只套用在紅字檔案</div>
        </div>
      </div>

      <div id="note1" class="note-box hidden">
上傳格式示例（txt 檔，可換行或空白分隔）：
0003
0018
1234
5678

紅字大萬 / 小萬只套用於紅字檔案，與其他號碼分開計算。
      </div>

      <div id="redSummary"></div>
    </section>

    <!-- Step 2 -->
    <section class="card">
      <div class="card-head">
        <div class="step">
          <div class="step-badge">2</div>
          <div class="card-title">設定「其他號碼」的大萬 / 小萬</div>
        </div>
        <div class="toggle-btn" onclick="toggleNote('note2', this)">ⓘ 顯示說明</div>
      </div>

      <div class="form-row">
        <div class="form-item">
          <label>大萬 (Big)</label>
          <input type="number" id="bigAmount" value="2" step="1" class="half-input" />
        </div>
        <div class="form-item">
          <label>小萬 (Small)</label>
          <input type="number" id="smallAmount" value="4" step="1" class="half-input" />
        </div>
      </div>

      <div id="note2" class="note-box hidden">
說明：
1. 只對「非紅字」的號碼套用。
2. 例：大萬=2，小萬=4 時，一般號碼會是：0000 2 4
3. 分散與倍數控制目前只支援 Big / Small 為整數。
      </div>
    </section>

    <!-- Step 3 -->
    <section class="card">
      <div class="card-head">
        <div class="step">
          <div class="step-badge">3</div>
          <div class="card-title">設定 Roll 比例（以家族為母數）</div>
        </div>
        <div class="toggle-btn" onclick="toggleNote('note3', this)">ⓘ 顯示說明</div>
      </div>

      <div class="form-row">
        <div class="form-item" style="grid-column: 1 / -1;">
          <label>Roll 比例 (%)</label>
          <input type="number" id="rollRatio" value="0" min="0" max="100" class="full-input" />
          <div class="hint">以「可成 r 的家族數」為母數抽選</div>
        </div>
      </div>

      <div id="note3" class="note-box hidden">
Roll 選號規則（以「家族」為母數）：
1. 0000-9999（扣紅字）依「數字組合」分家族，例如：
   0015 / 0105 / 1500 / 5001... -> 同一家族。
2. 一個家族可成 r 條件：
   - 家族內全部成員都不是紅字（有紅字就整組封印）
   - 這組數字本身至少 2 種不同數字
3. Roll 比例以「可成 r 的家族數」為母數取比例。
4. 被選中的家族只輸出 1 個 baseline r，其餘排列不再出現。
      </div>
    </section>

    <!-- Step 4 -->
    <section class="card">
      <div class="card-head">
        <div class="step">
          <div class="step-badge">4</div>
          <div class="card-title">設定分散比例</div>
        </div>
        <div class="toggle-btn" onclick="toggleNote('note4', this)">ⓘ 顯示說明</div>
      </div>

      <div class="form-row">
        <div class="form-item" style="grid-column: 1 / -1;">
          <label>分散比例 (%)</label>
          <input type="number" id="spreadRatio" value="0" min="0" max="100" class="full-input" />
          <div class="hint">一般號碼與 r 號碼都可能被分散</div>
        </div>
      </div>

      <div id="note4" class="note-box hidden">
分散邏輯：
1. 依比例隨機選出要分散的行（一般 + r）。
2. 被選中的行拆成多行，Big/Small 總和不變。
3. 拆分後會盡量避免出現 Big=0 且 Small=0 的行。
4. 未被選中則維持一行。
      </div>
    </section>

    <!-- Step 5 -->
    <section class="card">
      <div class="card-head">
        <div class="step">
          <div class="step-badge">5</div>
          <div class="card-title">設定行數倍數</div>
        </div>
        <div class="toggle-btn" onclick="toggleNote('note5', this)">ⓘ 顯示說明</div>
      </div>

      <div class="form-row">
        <div class="form-item" style="grid-column: 1 / -1;">
          <label>行數倍數</label>
          <input type="number" id="lineMultiplier" value="1.0" step="0.1" min="1" class="full-input" />
          <div class="hint">控制分散後的總行數接近倍數目標</div>
        </div>
      </div>

      <div id="note5" class="note-box hidden">
說明：
1. 基礎行數 = Roll 後、未分散前行數（不含紅字）。
2. 倍數 1.4 → 目標 ≈ 基礎行數 × 1.4
3. 分散比例決定選誰拆；倍數決定每行拆幾份。
4. 若倍數過小，會以「可達最小值」為準。
      </div>
    </section>

    <!-- Actions -->
    <section class="card">
      <div class="card-head">
        <div class="step">
          <div class="step-badge">✓</div>
          <div class="card-title">產生分析 & 下載結果</div>
        </div>
      </div>

      <div class="actions">
        <button class="btn-primary" id="analyzeBtn">產生分析</button>
        <button class="btn-secondary" id="downloadBtn">下載 txt 檔</button>
      </div>

      <div id="status" class="msg"></div>
    </section>
  </div>

  <script>
    // ========= GENv9 JS 全保留（不改邏輯） =========

    function toggleNote(id, btnEl) {
      const note = document.getElementById(id);
      if (!note) return;
      if (note.classList.contains('hidden')) {
        note.classList.remove('hidden');
        btnEl.textContent = 'ⓘ 隱藏說明';
      } else {
        note.classList.add('hidden');
        btnEl.textContent = 'ⓘ 顯示說明';
      }
    }

    function downloadTextFile(filename, content) {
      const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    let redSet = new Set();
    let redRForbiddenSet = new Set();

    let lastRedContent = '';
    let lastOtherContent = '';
    let lastStatsText = '';
    let hasAnalysis = false;

    const redFileInput = document.getElementById('redFile');
    const redSummary = document.getElementById('redSummary');
    const statusDiv = document.getElementById('status');

    function setStatus(text, type = 'ok') {
      statusDiv.textContent = text;
      statusDiv.className = 'msg';
      if (type === 'ok') statusDiv.classList.add('status-ok');
      else if (type === 'warn') statusDiv.classList.add('status-warn');
      else if (type === 'error') statusDiv.classList.add('status-error');
    }

    function getPermutations(numStr) {
      const chars = numStr.split('');
      const results = new Set();
      function backtrack(path, used) {
        if (path.length === chars.length) { results.add(path.join('')); return; }
        for (let i = 0; i < chars.length; i++) {
          if (used[i]) continue;
          used[i] = true; path.push(chars[i]);
          backtrack(path, used);
          path.pop(); used[i] = false;
        }
      }
      backtrack([], Array(chars.length).fill(false));
      return Array.from(results);
    }

    function canBeR(num) {
      const uniqueDigits = new Set(num.split(''));
      return uniqueDigits.size >= 2;
    }

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    function randomPartition(sum, parts) {
      if (sum <= 0) return Array(parts).fill(0);
      const cuts = [];
      for (let i = 0; i < parts - 1; i++) cuts.push(Math.floor(Math.random() * (sum + 1)));
      cuts.sort((a, b) => a - b);
      const result = [];
      let prev = 0;
      for (let i = 0; i < parts - 1; i++) { result.push(cuts[i] - prev); prev = cuts[i]; }
      result.push(sum - prev);
      return result;
    }

    function generateNonZeroZeroParts(totalBig, totalSmall, partsCount) {
      let bigParts = [];
      let smallParts = [];
      let ok = false;

      for (let attempt = 0; attempt < 20; attempt++) {
        bigParts = randomPartition(totalBig, partsCount);
        smallParts = randomPartition(totalSmall, partsCount);
        ok = true;
        for (let j = 0; j < partsCount; j++) {
          if (bigParts[j] === 0 && smallParts[j] === 0) { ok = false; break; }
        }
        if (ok) return { bigParts, smallParts };
      }

      for (let j = 0; j < partsCount; j++) {
        if (bigParts[j] === 0 && smallParts[j] === 0) {
          let borrowed = false;
          for (let k = 0; k < partsCount; k++) {
            if (k === j) continue;
            if (bigParts[k] > 0) { bigParts[k] -= 1; bigParts[j] += 1; borrowed = true; break; }
          }
          if (!borrowed) {
            for (let k = 0; k < partsCount; k++) {
              if (k === j) continue;
              if (smallParts[k] > 0) { smallParts[k] -= 1; smallParts[j] += 1; break; }
            }
          }
        }
      }
      return { bigParts, smallParts };
    }

    redFileInput.addEventListener('change', function () {
      const file = redFileInput.files[0];
      redSet = new Set();
      redRForbiddenSet = new Set();
      redSummary.textContent = '';
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function (e) {
        const text = e.target.result || '';
        const tokens = text.split(/\s+/).map(t => t.trim()).filter(Boolean);

        let totalTokens = 0;
        let invalidTokens = [];

        tokens.forEach(tok => {
          totalTokens++;
          if (/^\d{4}$/.test(tok)) redSet.add(tok);
          else invalidTokens.push(tok);
        });

        redSet.forEach(rn => {
          if (canBeR(rn)) {
            const perms = getPermutations(rn);
            perms.forEach(p => { if (!redSet.has(p)) redRForbiddenSet.add(p); });
          }
        });

        let msg = `已讀取紅字（不重複）：${redSet.size} 組\n原始欄位數：${totalTokens}`;
        if (invalidTokens.length > 0) msg += `\n有 ${invalidTokens.length} 個不是 4 位數，已忽略。`;
        msg += `\n禁止成為 r 基底的排列家族成員數量：${redRForbiddenSet.size}`;
        redSummary.textContent = msg;
      };
      reader.onerror = function () { redSummary.textContent = '讀取檔案失敗，請再試一次。'; };
      reader.readAsText(file, 'utf-8');
    });

    function runAnalysis() {
      const redBig = parseFloat(document.getElementById('redBigAmount').value || '0') || 0;
      const redSmall = parseFloat(document.getElementById('redSmallAmount').value || '0') || 0;

      const big = parseFloat(document.getElementById('bigAmount').value || '0') || 0;
      const small = parseFloat(document.getElementById('smallAmount').value || '0') || 0;
      let rollRatio = parseFloat(document.getElementById('rollRatio').value || '0') || 0;
      let spreadRatio = parseFloat(document.getElementById('spreadRatio').value || '0') || 0;
      let lineMultiplier = parseFloat(document.getElementById('lineMultiplier').value || '1') || 1;

      if (rollRatio < 0) rollRatio = 0;
      if (rollRatio > 100) rollRatio = 100;
      if (spreadRatio < 0) spreadRatio = 0;
      if (spreadRatio > 100) spreadRatio = 100;
      if (lineMultiplier < 1) lineMultiplier = 1;

      const bigIsInt = Number.isInteger(big);
      const smallIsInt = Number.isInteger(small);

      if (!redFileInput.files[0]) {
        if (!confirm('尚未上傳紅字檔，確定要直接產生 0000-9999 全部號碼？')) {
          setStatus('已取消產生分析。', 'warn');
          return;
        }
      }

      const nonRedNumbers = [];
      const familyMap = {};

      for (let i = 0; i < 10000; i++) {
        const num = i.toString().padStart(4, '0');
        if (redSet.has(num)) continue;

        nonRedNumbers.push(num);
        const key = num.split('').sort().join('');
        if (!familyMap[key]) familyMap[key] = { members: [] };
        familyMap[key].members.push(num);
      }

      const candidateFamilies = [];
      for (const key in familyMap) {
        const members = familyMap[key].members;
        if (!members || members.length === 0) continue;

        const sample = members[0];
        if (!canBeR(sample)) continue;
        if (redRForbiddenSet.has(sample)) continue;

        candidateFamilies.push({ key, members });
      }

      let chosenFamilyKeys = new Set();
      if (rollRatio > 0 && candidateFamilies.length > 0) {
        shuffle(candidateFamilies);
        const totalFamilies = candidateFamilies.length;
        const targetFamilies = Math.floor(totalFamilies * (rollRatio / 100));
        const chosen = candidateFamilies.slice(0, targetFamilies);
        chosen.forEach(f => chosenFamilyKeys.add(f.key));
      }

      const baselineMap = {};
      candidateFamilies.forEach(f => {
        if (!chosenFamilyKeys.has(f.key)) return;
        const members = f.members;
        const rndIndex = Math.floor(Math.random() * members.length);
        baselineMap[f.key] = members[rndIndex];
      });

      const entries = [];
      nonRedNumbers.forEach(num => {
        const key = num.split('').sort().join('');
        if (chosenFamilyKeys.has(key)) {
          if (baselineMap[key] === num) entries.push({ num: num + 'r', isR: true, big, small });
        } else {
          entries.push({ num, isR: false, big, small });
        }
      });

      const baseLines = entries.length;

      let redLinesText = [];
      let redLinesCount = 0;
      if (redSet.size > 0) {
        const sortedReds = Array.from(redSet).sort();
        redLinesText = sortedReds.map(num => `${num} ${redBig} ${redSmall}`);
        redLinesCount = redLinesText.length;
      }

      if (!bigIsInt || !smallIsInt) {
        const linesText = entries.map(e => `${e.num} ${e.big} ${e.small}`);

        lastRedContent = redLinesText.join('\n');
        lastOtherContent = linesText.join('\n');
        hasAnalysis = true;

        let msg =
          `Big / Small 不是整數，分散與倍數控制未啟用。\n` +
          `紅字行數：${redLinesCount} 行（檔名：red_numbers.txt）\n` +
          `其他基礎行數（Roll 後未分散）：${baseLines} 行。\n` +
          `其他檔案檔名：other_numbers.txt\n\n` +
          `分析已完成，如要下載請按「下載 txt 檔」。`;
        lastStatsText = msg;
        setStatus(msg, 'warn');
        return;
      }

      const eligibleIndices = [];
      for (let i = 0; i < entries.length; i++) eligibleIndices.push(i);

      let spreadCount = 0;
      let selectedSpreadIndices = [];
      if (spreadRatio > 0 && eligibleIndices.length > 0) {
        shuffle(eligibleIndices);
        spreadCount = Math.floor(eligibleIndices.length * (spreadRatio / 100));
        selectedSpreadIndices = eligibleIndices.slice(0, spreadCount);
      }

      let targetLinesRaw = Math.round(baseLines * lineMultiplier);
      const minLines = baseLines + spreadCount;
      if (targetLinesRaw < minLines) targetLinesRaw = minLines;

      const additionalNeeded = targetLinesRaw - baseLines;
      const parts = new Array(entries.length).fill(1);

      let currentExtra = 0;
      selectedSpreadIndices.forEach(idx => { parts[idx] = 2; currentExtra += 1; });

      let remainingExtra = additionalNeeded - currentExtra;
      if (remainingExtra < 0) remainingExtra = 0;

      const spreadN = selectedSpreadIndices.length;
      while (remainingExtra > 0 && spreadN > 0) {
        const idx = selectedSpreadIndices[Math.floor(Math.random() * spreadN)];
        parts[idx] += 1;
        remainingExtra -= 1;
      }

      const linesText = [];
      let zeroZeroLines = 0;

      for (let i = 0; i < entries.length; i++) {
        const entry = entries[i];
        const p = parts[i];

        if (p === 1) {
          if (entry.big === 0 && entry.small === 0) zeroZeroLines++;
          linesText.push(`${entry.num} ${entry.big} ${entry.small}`);
        } else {
          const { bigParts, smallParts } = generateNonZeroZeroParts(entry.big, entry.small, p);
          for (let j = 0; j < p; j++) {
            const bVal = bigParts[j];
            const sVal = smallParts[j];
            if (bVal === 0 && sVal === 0) zeroZeroLines++;
            linesText.push(`${entry.num} ${bVal} ${sVal}`);
          }
        }
      }

      const finalLines = linesText.length;

      lastRedContent = redLinesText.join('\n');
      lastOtherContent = linesText.join('\n');
      hasAnalysis = true;

      let msg =
        `分析已完成（尚未下載檔案）。\n` +
        `紅字行數：${redLinesCount} 行（檔名：red_numbers.txt）\n` +
        `其他基礎行數（Roll 後未分散）：${baseLines}\n` +
        `被選中分散的行數：${spreadCount}\n` +
        `設定行數倍數：${lineMultiplier}\n` +
        `實際輸出行數（含分散後）：${finalLines}\n` +
        `偵測到 Big=0 且 Small=0 的行數（理論上接近 0）：${zeroZeroLines}\n` +
        `其他檔案檔名：other_numbers.txt\n\n` +
        `若不滿意，可再按一次「產生分析」重新亂數。\n` +
        `確定可以後，再按「下載 txt 檔」下載目前這一版結果。`;

      lastStatsText = msg;
      setStatus(msg, 'ok');
    }

    document.getElementById('analyzeBtn').addEventListener('click', runAnalysis);

    document.getElementById('downloadBtn').addEventListener('click', function () {
      if (!hasAnalysis) {
        setStatus('尚未產生分析，請先按「產生分析」。', 'warn');
        return;
      }

      if (lastRedContent && lastRedContent.trim().length > 0) {
        downloadTextFile('red_numbers.txt', lastRedContent);
      }
      if (lastOtherContent && lastOtherContent.trim().length > 0) {
        downloadTextFile('other_numbers.txt', lastOtherContent);
      }

      setStatus(lastStatsText + '\n已下載 red_numbers.txt 與 other_numbers.txt（若有紅字）。', 'ok');
    });
  </script>
</body>
</html>
